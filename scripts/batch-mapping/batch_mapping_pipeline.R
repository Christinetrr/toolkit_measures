# setwd("Replace this string with the path to the batch-mapping directory of this repo and uncomment")
# The Toolkit only needs to be loaded once
load("../../Toolkit_v2.0.RData")

# This script outlines the pipeline for mapping spellings and pronunciations with optional prefedined frequencies through
# the map_GRAIN -> make_tables -> map_value pipeline.
# Datasets are generated and saved to the global environment, which is often useful especailly when datasets need to
# be referenced multiple times, as variable assignment becomes tedious. Each function returns a list of strings of
# the generated datasets, useful for batch-removing them from the global environment with the rm() function.

# Grain sizes mapped to the relevant suffixes for dataset naming
grain_sizes <- list(
    "PG" = "_PG",
    "ONC" = "_ONC",
    "OC" = "_OC",
    "OR" = "_OR"
)
# Weightings mapped to relevant suffixes for dataset naming
weight_options <- list(
    "default" = "", 
    "noposition" = "_noposition", 
    "freq" = "_freq", 
    "freq_noposition" = "_freq_noposition"
)

# Takes a list of spellings, a list of corresponding pronunciations, and maps them at all grain sizes outlined
# in the grain_sizes list. Values of the grain_sizes list correspond to the relevant suffixes for dataset naming.
# output_name is used as the root of the datasets generated.
# i.e. if name = "mwords" and grain_sizes has "PG" = "_PG", the dataset generated will be named mwords_PG and mapping
# will be done at the PG level.
# Returns a list of strings corresponding to the names of the generated datasets.
# Datasets are stored in the global environment - be advised that this function will overwrite any existing variables
# in the environment with the same names as those that are generated here!
batch_map_words <- function(spellings, pronunciations, grain_sizes, output_name) {
    dataset_names <- c()

    for (grain in names(grain_sizes)) {
        # Name of the mapped words dataset to be stored
        var_name <- paste0(output_name, grain_sizes[[grain]])

        # Call the relevant map function at the desired level
        data <- get(paste0("map", grain_sizes[[grain]]))(spellings, pronunciations, FALSE)

        # Save the dataset to the environment
        assign(var_name, data, envir = .GlobalEnv)

        # Add name of generated dataset to list
        dataset_names <- c(dataset_names, var_name)
    }

    # Return a list of names of generated datasets for easy removal from the environment later
    return(dataset_names)
}

# Takes in the root name of datasets processed by the "map" family of functions, as well as lists of grain sizes and weight options.
# Weight data must be provided if freq measures are to be calculated. Finally, takes in the root name for the tables to be
# generated - if the datasets passed in were generated by the batch_map_words function, then the mapped_words_name argument here
# should be the same as the output_name argument of said function.
# Calls the make_tables function on all relevant datasets (assumed to exist in the global environment) for all combinations of grain
# and weight, naming them appropriately.
# Outputs of this function can be indexed with the summarize_words function, and equivalently fed into the extract_all_measures
# pipeline - see the all-measures folder of this repo.
# Returns a list of strings corresponding to the names of the generated datasets.
# Datasets are stored in the global environment - be advised that this function will overwrite any existing variables
# in the environment with the same names as those that are generated here!
batch_make_tables <- function(mapped_words_name, grain_sizes, weight_options, weight_data, output_name) {
    dataset_names <- c()

    for (grain in names(grain_sizes)) {
        mapped_words <- get(paste0(mapped_words_name, grain_sizes[[grain]]))
        for (weight in names(weight_options)) {
            var_name <- paste0(output_name, grain_sizes[[grain]], weight_options[[weight]])
            data <- c() # init empty

            if (weight == "default") {
                data <- make_tables(mapped_words)
            } else if (weight == "noposition") {
                data <- make_tables(mapped_words, positional = FALSE)
            } else if (weight == "freq") {
                data <- make_tables(mapped_words, weight = weight_data)
            } else if (weight == "freq_noposition") {
                data <- make_tables(mapped_words, weight = weight_data, positional = FALSE)
            }
            assign(var_name, data, envir = .GlobalEnv)

            dataset_names <- c(dataset_names, var_name)
        }
    }

    return(dataset_names)
}

# Takes in a list of spellings and pronunciations, the root name of the relevant tables as formed by the make_tables function,
# and lists of grain sizes and weights. Also takes in the root name of the datasets to be generated from the map_value function.
# If the relevant tables used were generated by the batch_make_tables function, table_name should be the same as the output_name argument
# of the batch_make_tables function.
# Calls the map_value function on all relevant tables for all provided grain sizes and weights. Assumes said tables exist in
# the global environment.
# Returns a list of strings corresponding to the names of the generated datasets.
# Datasets are stored in the global environment - be advised that this function will overwrite any existing variables
# in the environment with the same names as those that are generated here!
batch_map_values <- function(spellings, pronunciations, table_name, grain_sizes, weight_options, output_name) {
    dataset_names <- c()
    
    for (grain in names(grain_sizes)) {
        for (weight in names(weight_options)) {
            data_table <- get(paste0(table_name, grain_sizes[[grain]], weight_options[[weight]]))
            var_name <- paste0(output_name, grain_sizes[[grain]], weight_options[[weight]])

            data <- map_value(spellings, pronunciations, grain, data_table)

            assign(var_name, data, envir = .GlobalEnv)

            dataset_names <- c(dataset_names, var_name)
        }
    }

    return(dataset_names)
}

